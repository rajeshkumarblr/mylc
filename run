#!/usr/bin/env bash
# Simple runner for build/<lang>/runner
# Language comes from LC_LANG (env). Override with -l/--lang.
# -c/--category <cat>   Run a category
# -a/--all              Run all (LC_PROB_NUM=all)
# -l (no arg) or -L     List categories & problems
# -h/--help or no args  Usage
# -s, --submit <id>     Extract and submit online (lang from -l or $LC_LANG)
set -Eeuo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

usage() {
  cat <<'EOF'
Usage:
  ./run [options]

Options:
  -l, --lang [cpp|go]  With an argument: set language (default from $LC_LANG via .env, else cpp)
                       Without an argument: list categories & problems
  -t [cpp|go]          Set default language in .env (writes LC_LANG) and exit
  -p, --problem [id]   Run a single problem id (if omitted, uses $LC_PROB_NUM or $LC_PROB_NO)
  -c, --category [cat] Run the given category (if omitted, uses $LC_CATEGORY)
  -a, --all            Run all problems (sets LC_PROB_NUM=all)
  -L                   List categories & problems (same as bare -l)
  -h, --help           Show this help
  -s, --submit <id>    Extract and submit via vsc-leetcode-cli (lang from -l or $LC_LANG)

Notes:
  • Runs prebuilt binaries: build/<lang>/runner
  • If the runner is missing, this script auto-builds it via: make -C src/<lang> all
  • Exports LC_PROB_NUM / LC_CATEGORY for the runners
  • Errors out if a single problem is requested but not implemented in the selected language

Examples:
  ./run -p 94
  ./run -l go -p 94
  ./run -t go      # persist default language
  ./run -c sliding_window
  ./run -a
  ./run -l        # list
  ./run -L        # list
  ./run -s 9 -l cpp   # extract + submit problem 9 (C++)
EOF
}

die() { echo "ERROR: $*" >&2; exit 2; }

# --- Load environment from .env
if [[ -f "$ROOT/.env" ]]; then
  # shellcheck disable=SC1091
  source "$ROOT/.env"
fi

# --- Discover default language safely ---
DEFAULT_LANG="${LC_LANG:-cpp}"

# --- Helpers ---
runner_path() { echo "$ROOT/build/$1/runner"; }

ensure_runner() {
  local lang="$1" bin; bin="$(runner_path "$lang")"
  if [[ ! -x "$bin" ]]; then
    echo "Runner missing: $bin"
    echo "→ Building via: make -C src/$lang all"
    make -C "$ROOT/src/$lang" all || die "Build failed for language '$lang'"
    [[ -x "$bin" ]] || die "Build succeeded but runner still missing: $bin"
  fi
}

list_from_testcases() {
  python3 - <<'PY'
import json, sys
from pathlib import Path

p = Path("testcases.json")
if not p.exists():
    print("ERROR: testcases.json not found", file=sys.stderr); sys.exit(2)

data = json.loads(p.read_text(encoding="utf-8"))
probs = data.get("problems", data)

def it():
    if isinstance(probs, dict):
        for k, v in probs.items(): yield str(k), v
    else:
        for v in probs: yield str(v.get("id","")), v

rows, cats = [], set()
for k, v in it():
    desc = (v.get("description") or "").strip()
    cat  = (v.get("category") or "misc").strip()
    cats.add(cat)
    try: key = int(k)
    except: key = 10**9
    rows.append((key, k, cat, desc))

rows.sort()
print("Categories:")
for c in sorted(cats):
    print("  -", c)
print("\nProblems:")
print("  ID   Category             Title")
for _, k, c, d in rows:
    print(f"  {k:<4} {c:<20} {d}")
PY
}

problem_exists_in_tests() {
  local id="$1"
  python3 - "$id" <<'PY'
import json, sys
from pathlib import Path
pid = sys.argv[1]
d = json.loads(Path("testcases.json").read_text(encoding="utf-8"))
p = d.get("problems", d)
ok = (pid in p) if isinstance(p, dict) else any(str(x.get("id"))==pid for x in p)
sys.exit(0 if ok else 1)
PY
}

has_impl() {
  local lang="$1" id="$2"
  shopt -s nullglob
  local m=()
  case "$lang" in
    cpp)
      m=( \
        "$ROOT/src/cpp/${id}."*".cpp" "$ROOT/src/cpp/${id}.cpp" \
        "$ROOT/src/cpp/hash/${id}."*".cpp" "$ROOT/src/cpp/list/${id}."*".cpp" \
        "$ROOT/src/cpp/sliding_window/${id}."*".cpp" "$ROOT/src/cpp/misc/${id}."*".cpp" \
        "$ROOT/src/cpp/two_pointer/${id}."*".cpp" "$ROOT/src/cpp/tree/${id}."*".cpp"
      )
      ;;
    go)
      m=( \
        "$ROOT/src/go/${id}."*".go" "$ROOT/src/go/${id}.go" \
        "$ROOT/src/go/hash/${id}."*".go" "$ROOT/src/go/list/${id}."*".go" \
        "$ROOT/src/go/sliding_window/${id}."*".go" "$ROOT/src/go/misc/${id}."*".go" \
        "$ROOT/src/go/two_pointer/${id}."*".go" "$ROOT/src/go/tree/${id}."*".go"
      )
      ;;
    *)   shopt -u nullglob; return 1;;
  esac
  shopt -u nullglob
  [[ ${#m[@]} -gt 0 ]]
}

print_lang() {
  case "$1" in
    cpp) echo "Language set to: C++" ;;
    go)  echo "Language set to: Go"  ;;
    *)   echo "Language set to: $1"  ;;
  esac
}

# --- Parse args ---
LANG="$DEFAULT_LANG"
PROB=""
CATEGORY=""
RUN_ALL=0
LIST_ONLY=0
SUBMIT_ID=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    -t)
      # Set default language by updating $ROOT/.env (LC_LANG)
      if [[ $# -ge 2 && "$2" =~ ^(cpp|go)$ ]]; then
        TARGET_LANG="$2"
        # Create or update .env with LC_LANG entry
        if [[ -f "$ROOT/.env" ]]; then
          # if LC_LANG exists, replace it; else append
          if grep -q '^LC_LANG=' "$ROOT/.env"; then
            sed -i -E 's/^LC_LANG=.*/LC_LANG='"$TARGET_LANG"'/' "$ROOT/.env"
          else
            echo "LC_LANG=$TARGET_LANG" >> "$ROOT/.env"
          fi
        else
          echo "LC_LANG=$TARGET_LANG" > "$ROOT/.env"
        fi
        echo "Default language set to '$TARGET_LANG' in .env (LC_LANG)"
        exit 0
      else
        die "-t requires one of: cpp|go"
      fi
      ;;
    -l|--lang)
      # If next token looks like a valid lang, consume it; else treat bare -l as "list"
      if [[ $# -ge 2 && "$2" =~ ^(cpp|go)$ ]]; then
        LANG="$2"; shift 2
      else
        LIST_ONLY=1; shift
      fi
      ;;
    -L)
      LIST_ONLY=1; shift ;;
    -p|--problem)
      if [[ $# -ge 2 && ! "$2" =~ ^- ]]; then
        PROB="$2"; shift 2
      else
        PROB="${LC_PROB_NUM:-${LC_PROB_NO:-}}"
        [[ -n "$PROB" ]] || die "--problem requires an id (or set $LC_PROB_NUM)"
        shift 1
      fi ;;
    -c|--category)
      if [[ $# -ge 2 && ! "$2" =~ ^- ]]; then
        CATEGORY="$2"; shift 2
      else
        CATEGORY="${LC_CATEGORY:-}"
        [[ -n "$CATEGORY" ]] || die "--category requires a value (or set $LC_CATEGORY)"
        shift 1
      fi;;
    -a|--all)
      RUN_ALL=1; shift ;;
    -h|--help)
      usage; exit 0 ;;
    -s|--submit)
      [[ $# -ge 2 ]] || die "--submit requires an id"
      SUBMIT_ID="$2"; shift 2 ;;
    -*)
      die "Unknown option: $1" ;;
    *)
      die "Unknown option or unexpected argument: $1" ;;
  esac
done

# No options/args => print usage
if [[ -z "$PROB" && -z "$CATEGORY" && $RUN_ALL -eq 0 && $LIST_ONLY -eq 0 && -z "$SUBMIT_ID" ]]; then
  usage; exit 0
fi

# Listing mode doesn't require building
if [[ $LIST_ONLY -eq 1 ]]; then
  list_from_testcases; exit 0
fi

# Submit path: extract then submit online; no runner build needed
if [[ -n "$SUBMIT_ID" ]]; then
  # Preflight checks
  command -v python3 >/dev/null 2>&1 || die "python3 not found; required for submit"
  [[ -f "$ROOT/scripts/submit_lc.py" ]] || die "scripts/submit_lc.py not found"
  if ! command -v leetcode >/dev/null 2>&1; then
    cat >&2 <<'EOT'
ERROR: `leetcode` CLI not found. Please install and login with vsc-leetcode-cli:
  npm uninstall -g leetcode-cli
  npm install -g vsc-leetcode-cli
  leetcode user login
EOT
    exit 2
  fi
  # Choose language: explicit -l overrides, else LC_LANG, default cpp
  LANG_FOR_SUBMIT="${LANG:-${LC_LANG:-cpp}}"
  echo "Submitting problem $SUBMIT_ID for language '$LANG_FOR_SUBMIT'..."
  exec python3 "$ROOT/scripts/submit_lc.py" --id "$SUBMIT_ID" --lang "$LANG_FOR_SUBMIT" --src-root "$ROOT/src" --build-root "$ROOT/build"
fi
case "$LANG" in cpp|go) : ;; *) die "Unsupported language: $LANG (use cpp|go)";; esac
print_lang "$LANG"
ensure_runner "$LANG"
BIN="$(runner_path "$LANG")"

# Prepare env for runner: set only what's requested, keep existing defaults from .env
if [[ -n "$CATEGORY" ]]; then
  export LC_CATEGORY="$CATEGORY"
  unset LC_PROB_NUM || true
  echo "Mode: category='$LC_CATEGORY'"
  echo "→ $BIN"
  exec "$BIN"
elif [[ $RUN_ALL -eq 1 ]]; then
  export LC_PROB_NUM="all"
  unset LC_CATEGORY || true
  echo "Mode: run all (LC_PROB_NUM=$LC_PROB_NUM)"
  echo "→ $BIN"
  exec "$BIN"
elif [[ -n "$PROB" ]]; then
  problem_exists_in_tests "$PROB" || die "Problem $PROB not found in testcases.json"
  has_impl "$LANG" "$PROB" || die "Problem $PROB is not implemented for language '$LANG'"
  export LC_PROB_NUM="$PROB"
  unset LC_CATEGORY || true
  echo "Mode: single problem $LC_PROB_NUM"
  echo "→ $BIN"
  exec "$BIN"
fi
